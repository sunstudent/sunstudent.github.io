<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[vue--组件]]></title>
    <url>%2F2019%2F09%2F01%2Fvue-%E7%BB%84%E4%BB%B6%2F</url>
    <content type="text"><![CDATA[组件化开发介绍WEB中的组件是页面组成的一部分，是一个具有独立逻辑的功能或界面，同时又能根据规定的接口规则进行融合，变成一个完整的应用。比如导航，列表，弹窗等。将一个巨大复杂的东西分成粒度合理的小东西。 优点:提高开发效率，方便重复使用，简化调试步骤，提升整个项目的可维护性，便于协同开发。Link : Element可以学习里面的组件开发 Vue中的组件vue中的组件是一个自定义标签，在哪里写上这个标签就可以在这里使用即插入组件。基本组成：样式结构，行为逻辑，数据。 注册组件分为全局注册与局部注册。 1.全局注册可以在任何模板中使用。语法：使用Vue.component(“组件名”, 选项对象)其中组件名命名约定：驼峰（camelCase）或 烤串（kebab-case）使用：在html中组件时必须使用烤串命名法的标签，插入组件在该位置。例：一个简单的下拉组件123456789101112131415161718192021Vue.component(&quot;pull-list&quot;,&#123; template:`&lt;section class=&quot;warp&quot;&gt; &lt;div class=&quot;searchIpt clearFix&quot;&gt; &lt;div class=&quot;clearFix&quot;&gt; &lt;input type=&quot;text&quot; class=&quot;keyWord&quot; value=&quot;&quot; /&gt; &lt;input type=&quot;button&quot; value=&quot;查询&quot;&gt; &lt;span&gt;&lt;/span&gt; &lt;/div&gt; &lt;ul class=&quot;list&quot;&gt; &lt;li&gt;html+css&lt;/li&gt; &lt;li&gt;html5+css3&lt;/li&gt; &lt;li&gt;javascript&lt;/li&gt; &lt;li&gt;vue&lt;/li&gt; &lt;li&gt;jquery&lt;/li&gt; &lt;/ul&gt; &lt;/div&gt; &lt;/section&gt;`&#125;);new Vue(&#123; el:&quot;#app&quot;,&#125;); 在html中的使用：1234&lt;div id=&quot;app&quot;&gt; &lt;h2&gt;自定义的下拉框&lt;/h2&gt; &lt;pull-list&gt;&lt;/pull-list&gt; &lt;/div&gt; 受限制的元素在某些元素中放入了自定义标签，不符合w3标准，会解析错误。可以通过使用特殊属性 is 来解决这个问题，但还是不提倡的。 2、局部注册在组件实例vm中通过在选项对象的component中注册，只在所注册的作用域使用。如下，将组件custom-select写在实例中，这样只能在#app中使用。如果还有一个挂载app2的实例，是不可以使用的。1234567891011121314151617181920212223new Vue(&#123; el:&quot;#app&quot;, component:&#123; &quot;custom-select&quot;:&#123; template:`&lt;section class=&quot;warp&quot;&gt; &lt;div class=&quot;searchIpt clearFix&quot;&gt; &lt;div class=&quot;clearFix&quot;&gt; &lt;input type=&quot;text&quot; class=&quot;keyWord&quot; value=&quot;&quot; /&gt; &lt;input type=&quot;button&quot; value=&quot;查询&quot;&gt; &lt;span&gt;&lt;/span&gt; &lt;/div&gt; &lt;ul class=&quot;list&quot;&gt; &lt;li&gt;html+css&lt;/li&gt; &lt;li&gt;html5+css3&lt;/li&gt; &lt;li&gt;javascript&lt;/li&gt; &lt;li&gt;vue&lt;/li&gt; &lt;li&gt;jquery&lt;/li&gt; &lt;/ul&gt; &lt;/div&gt; &lt;/section&gt;` &#125; &#125;&#125;); 组件间的通信为什么通信：父组件要给子组件传递数据；子组件需要将它内部发生的事情告诉父组件。 1、父组件 给 子组件 传递数据组件实例的作用域是独立的，不能在子组件直接用父组件的数据。这里#app所在可以看做父组件，custom-select为子组件。要想自定义custom-select组件里面的一些信息，比如按钮显示搜索 而不是查询，这就需要向其传递一些数据。123456&lt;div id=&quot;app&quot;&gt; &lt;h2&gt;自定义的下拉框1&lt;/h2&gt; &lt;custom-select&gt;&lt;/custom-select&gt; &lt;h2&gt;自定义的下拉框2&lt;/h2&gt; &lt;custom-select&gt;&lt;/custom-select&gt; &lt;/div&gt; 方法：在自定义标签上来一个自定义属性，再在子组件中用props声明这个自定义的属性名。step1: html中使用传值：&lt;custom-select btn-value=”查询”&gt;123456&lt;div id=&quot;app&quot;&gt; &lt;h2&gt;自定义的下拉框1&lt;/h2&gt; &lt;custom-select btn-value=&quot;查询&quot;&gt;&lt;/custom-select&gt; &lt;h2&gt;自定义的下拉框2&lt;/h2&gt; &lt;custom-select btn-value=&quot;搜索&quot;&gt;&lt;/custom-select&gt; &lt;/div&gt; step2: 在组件props中声明自定义属性 step3: template模板中绑定属性12345678910111213141516171819Vue.component(&quot;custom-select&quot;,&#123; props:[&quot;btnValue&quot;], template:`&lt;section class=&quot;warp&quot;&gt; &lt;div class=&quot;searchIpt clearFix&quot;&gt; &lt;div class=&quot;clearFix&quot;&gt; &lt;input type=&quot;text&quot; class=&quot;keyWord&quot; value=&quot;&quot; /&gt; &lt;input type=&quot;button&quot; :value=&quot;btnValue&quot;&gt; &lt;span&gt;&lt;/span&gt; &lt;/div&gt; &lt;ul class=&quot;list&quot;&gt; &lt;li&gt;html+css&lt;/li&gt; &lt;li&gt;html5+css3&lt;/li&gt; &lt;li&gt;javascript&lt;/li&gt; &lt;li&gt;vue&lt;/li&gt; &lt;li&gt;jquery&lt;/li&gt; &lt;/ul&gt; &lt;/div&gt; &lt;/section&gt;` &#125;) 组件选项对象的data属性Question:让下拉列表一开始是隐藏的状态，在点击输入框时才显示？用到组件的选项对象里的data属性，注：组件中的data必须是函数。因为每个组件都是独立的，如果他们共用一个对象，在更改一个组件数据的时候，会影响其他组件；如果是函数的话，每个组件都有自己独立的数据，相互之间不会影响。然后通过绑定click事件来进行显隐控制，结合v-show和v-on指令实现：12345data:function()&#123; return &#123; selectShow:false &#125;;&#125;, 12&lt;input type=&quot;text&quot; class=&quot;keyWord&quot; value=&quot;&quot; @click=&quot;selectShow = !selectShow&quot; /&gt;&lt;custom-li v-show=&quot;selectShow&quot;&gt;&lt;/custom-li&gt; 上面的为ul列表组件，是的子组件。 更多层的数据传递#app是&lt;custom-select&gt;的父组件，&lt;custom-select&gt;是&lt;custom-li&gt;的父组件。这样的传递是一层一层往内传递，依次进行即可。 step1：实例化对象中要有数据1234data:&#123; list1:[&quot;北京&quot;,&quot;上海&quot;,&quot;杭州&quot;], list2:[&quot;2017-10-12&quot;,&quot;2017-10-20&quot;,&quot;2017-10-23&quot;]&#125; step2:html中使用组件并绑定属性12&lt;custom-select btn-value=&quot;查询&quot; :list=&quot;list1&quot;&gt;&lt;/custom-select&gt; &lt;custom-select btn-value=&quot;搜索&quot; :list=&quot;list2&quot;&gt;&lt;/custom-select&gt; step3:custom-select组件选项对象的props中添加自定义属性名1props:[&quot;btnValue&quot;,&quot;list&quot;] step4：子组件中绑定list属性1&lt;custom-li v-show=&quot;selectShow&quot; :list=&quot;list&quot;&gt;&lt;/custom-li&gt; step5：子组件添加声明自定义属性，模板中遍历list获得li12345props:[&quot;list&quot;],template:`&lt;ul class=&quot;list&quot;&gt; &lt;li v-for=&quot;item of list&quot;&gt;&#123;&#123;item&#125;&#125;&lt;/li&gt; &lt;/ul&gt; ` 这样就将数据传递了下来。 2、子组件 给 父组件 传递数据Question: 点击列表项时相应显示在输入框里？父组件传递数据到子组件用到自定义属性，子组件传递数据到父组件需要用到自定义事件。继续上面的例子：step1: 在子组件的li上添加点击事件1&lt;li v-for=&quot;item of list&quot; @click=&quot;selectValueHandle(item)&quot;&gt;&#123;&#123;item&#125;&#125;&lt;/li&gt; step2: 在子组件的methds里添加selectValueHandle函数，用来触发自定义事件1234selectValueHandle:function(item)&#123; //告知父级，改变val的值，需要触发一个自定义事件 this.$emit(&quot;recieve&quot;,item);&#125; step3：在父组件中的 custom-li标签 上绑定自定义事件1&lt;custom-li v-show=&quot;selectShow&quot; :list=&quot;list&quot; @recieve=&quot;changeValueHandle&quot;&gt;&lt;/custom-li&gt; step4:在父组件的methods里添加changeValueHandle函数123changeValueHandle:function(value)&#123; this.val=value;&#125; step5：将val双向绑定到input框。此时点击列表项就可以相应的显示到输入框了。 单向数据流数据从父组件流向（传递给）子组件，只能单向绑定。在子组件内部不允许直接修改父组件传递过来的数据。如果要改的话，可以： 将从父组件传递来的数据 作为data中数据来使用，然后改data里的值。2.作为子组件的computed属性 props验证组件可以为props绑定验证要求。如果类型不对，vue会警告。12345678910props:&#123; count:&#123; type:Number, //String,Number,Function,Object,Boolean,Array default:10, //默认值，不传参数时为这个值 required:true, //count参数必须传，不然报错 validator:function(value)&#123; //自定义验证规则，传的必须大于10，否则报错 return value&gt;10; &#125; &#125;&#125;, 内容分发使用一种方式混合父组件的内容和子组件自己的模板，这个过程称为内容分发。在子组件中使用特殊的元素作为内容的插槽。简单来说就是定制模板，自定义子组件中的内容。 单个slot向组件的html标签中添加内容：123&lt;custom&gt; &lt;div&gt;我是html标签&lt;/div&gt;&lt;/custom&gt; 向组件模板中加入标签，即可将html中自定义的内容呈现在slot位置，没有内容则显示slot模板中的默认内容：12345678template:` &lt;div&gt; &lt;slot&gt;我是默认的结构&lt;/slot&gt; &lt;p&gt;这是第一个提醒&lt;/p&gt; &lt;p&gt;这是第二个提醒&lt;/p&gt; &lt;p&gt;这是第三个提醒&lt;/p&gt; &lt;/div&gt; ` 当然，如果将slot标签包裹整个结构，则显示为父组件的内容。 具名slotslot标签可以用name属性来配置如何分发内容：1234567template:` &lt;div&gt; &lt;slot name=&quot;one&quot;&gt;&lt;p&gt;这是第一个提醒&lt;/p&gt;&lt;/slot&gt; &lt;slot name=&quot;two&quot;&gt;&lt;p&gt;这是第二个提醒&lt;/p&gt;&lt;/slot&gt; &lt;p&gt;这是第三个提醒&lt;/p&gt; &lt;/div&gt; ` 在html中对应要替换的部分：123&lt;custom&gt; &lt;div slot=&quot;one&quot;&gt;我是html标签&lt;/div&gt;&lt;/custom&gt; 这样，结果就为：我是html标签这是第二个提醒这是第三个提醒 组件封装props参数：数据传递给组件slot定制模板：外部模板混合子组件模板event自定义事件：监控子组件交互状态 动态组件多个组件可以使用同一挂载点，动态的在它们之间切换。使用元素加is特性进行动态绑定，决定显示哪一个组件。使用keep-alive把切出去的组件保存在内存中，这样再次切回来时可以保留它的状态，避免重新渲染。123456789101112131415161718192021222324252627282930313233343536373839404142&lt;div id=&quot;app&quot;&gt; &lt;input type=&quot;button&quot; value=&quot;切换到第1个组件&quot; @click=&quot;tabComponent(1)&quot; /&gt; &lt;input type=&quot;button&quot; value=&quot;切换到第2个组件&quot; @click=&quot;tabComponent(2)&quot;/&gt; &lt;input type=&quot;button&quot; value=&quot;切换到第3个组件&quot; @click=&quot;tabComponent(3)&quot;/&gt; &lt;keep-alive&gt; &lt;component :is=&quot;current&quot;&gt;&lt;/component&gt; &lt;/keep-alive&gt;&lt;/div&gt;&lt;script&gt; var custom1 = Vue.component(&quot;custom1&quot;,&#123; template:`&lt;div @click=&quot;changeDivbg&quot;&gt;我是第1个组件&lt;/div&gt;`, methods:&#123; changeDivbg(ev)&#123; ev.target.style.background = &quot;red&quot;; &#125; &#125; &#125;); var custom2 = Vue.component(&quot;custom2&quot;,&#123; template:`&lt;div&gt;我是第2个组件&lt;/div&gt;` &#125;) var custom3 = Vue.component(&quot;custom3&quot;,&#123; template:`&lt;div&gt;我是第3个组件&lt;/div&gt;` &#125;) new Vue(&#123; el:&quot;#app&quot;, data:&#123; current:custom1 &#125;, methods:&#123; tabComponent(index)&#123; if(index === 1)&#123; this.current = custom1 &#125;else if(index === 2)&#123; this.current = custom2 &#125;else if(index === 3)&#123; this.current = custom3 &#125; &#125; &#125; &#125;)&lt;/script&gt; Demo：下拉选择列表组件1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374&lt;!DOCTYPE html&gt;&lt;html lang=&quot;en&quot;&gt;&lt;head&gt; &lt;meta charset=&quot;UTF-8&quot;&gt; &lt;title&gt;下拉组件&lt;/title&gt; &lt;link rel=&quot;stylesheet&quot; type=&quot;text/css&quot; href=&quot;style.css&quot;&gt; &lt;script type=&quot;text/javascript&quot; src=&quot;vue.js&quot;&gt;&lt;/script&gt;&lt;/head&gt;&lt;body&gt; &lt;div id=&quot;app&quot;&gt; &lt;h2&gt;自定义的下拉选择框&lt;/h2&gt; &lt;custom-select btn-value=&quot;查询&quot; v-bind:list=&quot;list1&quot;&gt;&lt;/custom-select&gt; &lt;h2&gt;自定义的下拉选择框&lt;/h2&gt; &lt;custom-select btn-value=&quot;搜索&quot; v-bind:list=&quot;list2&quot;&gt;&lt;/custom-select&gt; &lt;/div&gt; &lt;script type=&quot;text/javascript&quot;&gt; Vue.component(&quot;custom-select&quot;,&#123; data:function()&#123; return &#123; selectShow:false, val:&apos;&apos; &#125;; &#125;, props:[&quot;btnValue&quot;,&quot;list&quot;], template:`&lt;section class=&quot;warp&quot;&gt; &lt;div class=&quot;searchIpt clearFix&quot;&gt; &lt;div class=&quot;clearFix&quot;&gt; &lt;input type=&quot;text&quot; class=&quot;keyWord&quot; value=&quot;&quot; @click=&quot;selectShow = !selectShow&quot; v-bind:value=&quot;val&quot;/&gt; &lt;input type=&quot;button&quot; v-bind:value=&quot;btnValue&quot;&gt; &lt;span&gt;&lt;/span&gt; &lt;/div&gt; &lt;custom-li v-show=&quot;selectShow&quot; v-bind:list=&quot;list&quot; v-on:recieve=&quot;changeValueHandle&quot; &gt;&lt;/custom-li&gt; &lt;/div&gt; &lt;/section&gt;`, methods:&#123; changeValueHandle:function(value)&#123; this.val=value; &#125; &#125; &#125;); //ul组件 Vue.component(&quot;custom-li&quot;,&#123; props:[&quot;list&quot;], template:`&lt;ul class=&quot;list&quot;&gt; &lt;li v-for=&quot;item of list&quot; @click=&quot;selectValueHandle(item)&quot;&gt;&#123;&#123;item&#125;&#125;&lt;/li&gt; &lt;/ul&gt;`, methods:&#123; selectValueHandle:function(item)&#123; //告知父级，改变val的值，需要触发一个自定义事件 this.$emit(&quot;recieve&quot;,item); &#125; &#125; &#125;); new Vue(&#123; el:&quot;#app&quot;, data:&#123; list1:[&quot;北京&quot;,&quot;上海&quot;,&quot;杭州&quot;], list2:[&quot;2017-10-12&quot;,&quot;2017-10-20&quot;,&quot;2017-10-23&quot;] &#125; &#125;); &lt;/script&gt;&lt;/body&gt;&lt;/html&gt;]]></content>
  </entry>
  <entry>
    <title><![CDATA[Vue 起步]]></title>
    <url>%2F2018%2F08%2F20%2F%E5%AD%A6%E4%B9%A0Vue%2F</url>
    <content type="text"><![CDATA[一、Vue是渐进式框架只关注视图层(view)，一点一点去使用。 二、vue中的两个核心点1. 响应的数据绑定当数据发生改变 -&gt; 自动更新视图。利用Object.definedProperty中的setter/getter代理数据，监控对数据的操作，发生了改变就立即重新渲染。不兼容ie8。关于Object.definedProperty()方法。单向绑定就是把Model绑定到View，当我们用JavaScript代码更新Model时，View就会自动更新。如果用户更新了View，Model的数据也自动被更新了，这种情况就是双向绑定。实现数据绑定的做法有以下几种：发布者-订阅者模式（backbone.js）：顾名思义，就是有订阅者和发布者，两者的功能，订阅是请求在某些事件(event)到达时可以通知它并执行对应的动作(action)，而发布则相对的是向订阅告知事件(event)已经到达，你可以执行对应的动作(action)了。脏值检查（angular.js）数据劫持（vue.js）：vue.js 则是采用[数据劫持结合发布者-订阅者模式]的方式，通过Object.defineProperty()来劫持各个属性的setter，getter，在数据变动时发布消息给订阅者，触发相应的监听回调。 组合的视图组件UI页面映射为组件树划分组件可维护，可重用，可测试 三、虚拟DOM运行js是很快的，但是大量的DOM操作却很慢，用js的做法是当某一个数据发生改变的时候，拼接我们的结构，用innerHtml一次性再渲染一遍。更新数据时重新渲染整个页面，即没有改变数据的地方也重新渲染了DOM 节点，造成很大的资源浪费。利用在内存中生成与真实DOM对应的数据结构，这个在内存中生成的结构成为虚拟DOM。当数据发生改变时，只渲染改变的地方，而不是重新渲染整个DOM树。第一步：模板123&lt;ul id=&quot;my-id&quot;&gt; &lt;li v-for=&apos;item in list&apos;&gt;&#123;&#123;item&#125;&#125;&lt;/li&gt;&lt;/ul&gt; 第二步：compile，模板调用内部的渲染函数。把模板中的标签拿出来调用createElement去生成这些标签。 第三步：render，形成虚拟dom树。也就是一个对象 第四步：create，编译成一个真实的dom。 四、MVVM模式 M：Model 数据模型V：view 视图模板VM：view-Model 视图模型 数据在M层，页面呈现在V层，相互独立的。VM层联系V和M。把数据绑定并呈现在V层；V与用户交互，页面发生改变，VM监听发生改变的事件，改变M层数据，再重新渲染V层。 五、Vue实例通过vue这个构造函数创建根实例。需要传入选项对象，包含挂载元素，数据，模板，方法等等。1234567891011121314151617&lt;div id=&quot;demo&quot;&gt; &lt;span v-on:click = &quot;clickHandle&quot;&gt;&#123;&#123; message &#125;&#125;&lt;/span&gt;&lt;/div&gt;&lt;script&gt; var data = &#123; message: &apos;hello pp&apos; &#125; var vm = new Vue(&#123; el: &apos;#demo&apos;, data: data, methods: &#123; clickHandle: function() &#123; alert(&apos;点击啦&apos;); &#125;, &#125; &#125;)&lt;/script&gt; 1.每个vue实例都会代理其data对象的所有属性，这些被代理的属性是响应的，但新添加的属性不具备响应。 2.vue实例自身的属性和方法 以$开头，如$el $data …在控制台打印出vm对象如下： 六、vue是声明式渲染声明式：只需要声明在哪里，做什么，无需关心如何实现。命令式：需要具体代码表达在哪里，做什么，如何实现。 七、指令指令是一种特殊的自定义行间属性；当表达式改变时相应的将某些行为应用到DOM上；在vue中，指令以v-开头。 vue中的内置指令：1. v-text123&lt;span v-text=&quot;msg&quot;&gt;&lt;/span&gt;&lt;!-- 和下面的一样 --&gt;&lt;span&gt;&#123;&#123;msg&#125;&#125;&lt;/span&gt; 2. v-html123456&lt;div v-html=&quot;html&quot;&gt;&lt;/div&gt;-------js-------var data = &#123; html:&apos;&lt;b&gt;加粗&lt;/b&gt;&apos;&#125; 在网站上动态渲染任意 HTML 是非常危险的，因为容易导致 XSS 攻击。只在可信内容上使用 v-html，永不用在用户提交的内容上。 3.v-show根据表达式真假，切换元素的 display CSS 属性。当条件变化时该指令触发过渡效果。123456789101112&lt;div id=&quot;demo&quot;&gt; &lt;h1 v-show=&quot;ok&quot;&gt;Hello!&lt;/h1&gt;&lt;/div&gt;&lt;script&gt; var data = &#123; ok: false &#125; var vm = new Vue(&#123; el: &apos;#demo&apos;, data: data &#125;)&lt;/script&gt; v-show与v-if的区别 1）v-show 指令与 v-if 指令都是根据条件展示元素。用法大致一样，不同的是带有 v-show 的元素始终会被渲染并保留在 DOM 中，只是简单地切换元素的 CSS 的display属性。 2) v-if 是“真正”的条件渲染，因为它会确保在切换过程中条件块内的事件监听器和子组件适当地被销毁和重建。 3）v-show 不支持 &lt;template&gt; 元素，也不支持 v-else。 4.v-if12&lt;h1 v-if=&quot;ok&quot;&gt;Yes&lt;/h1&gt;&lt;h1 v-else&gt;No&lt;/h1&gt; 5.v-else使用方法如上。 限制：前一兄弟元素必须有 v-if 或 v-else-if 6.v-else-if限制：前一兄弟元素必须有 v-if 或 v-else-if。必须使用特定语法 alias in expression1234567891011 A&lt;/div&gt;&lt;div v-else-if=&quot;type === &apos;B&apos;&quot;&gt; B&lt;/div&gt;&lt;div v-else-if=&quot;type === &apos;C&apos;&quot;&gt; C&lt;/div&gt;&lt;div v-else&gt; Not A/B/C&lt;/div&gt; 7.v-for必须使用特定语法 alias in expression。1234567891011121314151617&lt;div id=&quot;demo&quot;&gt; &lt;div v-for=&quot;item in items&quot;&gt; &lt;li&gt;&#123;&#123;item.text&#125;&#125;&lt;/li&gt; &lt;/div&gt;&lt;/div&gt;&lt;script&gt; var data = &#123; items: [ &#123;text: &apos;pp&apos;&#125;, &#123;text: &apos;haha&apos;&#125; ] &#125; var vm = new Vue(&#123; el: &apos;#demo&apos;, data: data &#125;)&lt;/script&gt; 8.v-on绑定事件监听器。缩写@ 9.v-bind动态地绑定一个或多个特性，或一个组件 prop 到表达式。缩写： 10.v-model在表单控件或者组件上创建双向绑定。 11.v-pre跳过这个元素和它的子元素的编译过程。可以用来显示原始 Mustache 标签。跳过大量没有指令的节点会加快编译。1&lt;span v-pre&gt;&#123;&#123; 不会被编译 &#125;&#125;&lt;/span&gt; 12.v-cloak 13.v-once只渲染元素和组件一次。 八、模板分为html模板，字符串模板，模板render函数 1.html模板基于DOM的模板，模板都是可解析的有效的HTML 插值类型：1）文本插值：使用”Mustache”语法（双大括号）。 作用：替换实例上的属性值，当值改变时，插值内容会自动更新。 2）原生的html：双大括号输出的是文本，不会解析html。 3）属性：使用v-bind来绑定属性，可以响应变化。123456789101112131415&lt;!-- 模板 --&gt;&lt;div id=&quot;demo&quot; v-bind:custom=&quot;abc&quot;&gt; //绑定属性；可以简写成 ：custom=&quot;abc&quot; &lt;div&gt;&#123;&#123;html&#125;&#125;&lt;/div&gt; //不解析html &lt;div v-html=&quot;html&quot;&gt;&lt;/div&gt; //会解析html，将html插入了div中&lt;/div&gt;&lt;script&gt; let obj = &#123; html:&quot;&lt;div&gt;hello&lt;/div&gt;&quot; abc:1 &#125; var vm = new Vue(&#123; el:&quot;#demo&quot;, data:obj &#125;);&lt;/script&gt; 4）使用javascript表达式：写简单的表达式，不要写语句。不建议这么写，以后使用计算属性。12&#123;&#123;3+1&#125;&#125;&#123;&#123; true ? &quot;yes&quot; : &quot;no&quot; &#125;&#125; 2.字符串模板1）模板会替换挂载元素，挂载元素的内容都将会被忽略；1234567891011121314&lt;div id=&quot;demo&quot;&gt; &lt;span&gt;haha&lt;/span&gt; //被忽略&lt;/div&gt;&lt;script&gt; let obj = &#123; abc:1 &#125; var str=&apos;&lt;div&gt;hello vue,&#123;&#123;abc&#125;&#125;&lt;/div&gt;&apos;; var vm = new Vue(&#123; el:&quot;#demo&quot;, data:obj, template:str &#125;);&lt;/script&gt; 2）字符串模板的根节点只能有一个；比如下面的写法会报错。1var str=&apos;&lt;div&gt;hello vue,&#123;&#123;abc&#125;&#125;&lt;/div&gt;&lt;span&gt;pp&lt;/span&gt;&apos;; 3）也可以将html做成一个片段，不放在字符串里，而是写在一个script标签中，设置type=”x-template”；12345678910111213&lt;script type=&quot;x-template&quot; id=&quot;temp&quot;&gt; &lt;div&gt;hello vue,&#123;&#123;abc&#125;&#125;&lt;/div&gt;&lt;/script&gt;&lt;script&gt; let obj = &#123; abc:1 &#125; var vm = new Vue(&#123; el:&quot;#demo&quot;, data:obj, template:&quot;#temp&quot; &#125;);&lt;/script&gt; 3.模板-render函数render 选项对象的属性 createElement(标签名，[数据对象]，子元素）； 其中子元素为文本或数组。12345678910111213141516171819&lt;div id=&quot;demo&quot;&gt;&lt;/div&gt;&lt;script&gt; var data = &#123; &#125; var vm = new Vue(&#123; el: &apos;#demo&apos;, data: data, render(createElement) &#123; return createElement( &quot;ul&quot;, [ createElement(&apos;li&apos;, 1), createElement(&quot;li&quot;, 2) ] ) &#125; &#125;)&lt;/script&gt; 如何给标签添加class：1234567891011121314151617&lt;style&gt; .red&#123; color:red; &#125;&lt;/style&gt;&lt;div id=&quot;demo&quot;&gt; &lt;span v-bind:class=&apos;&#123;red:addClass&#125;&apos;&gt;haha&lt;/span&gt;&lt;/div&gt;&lt;script&gt; let obj = &#123; addClass:true &#125;; var vm = new Vue(&#123; el:&quot;#demo&quot;, data:obj &#125;);&lt;/script&gt; 也可以通过模板render函数来添加class：12345678910111213141516171819202122232425262728&lt;style&gt; .red&#123; color:red; &#125;&lt;/style&gt;&lt;div id=&quot;demo&quot;&gt;&lt;/div&gt;&lt;script&gt; let obj = &#123; &#125;; var vm = new Vue(&#123; el:&quot;#demo&quot;, data:obj, render(createElement) &#123; return createElement( &quot;ul&quot;, &#123; class: &#123; red: true &#125; &#125;, [ createElement(&quot;li&quot;, 11), createElement(&quot;li&quot;, 22) ] ) &#125; &#125;);&lt;/script&gt; 其他操作：123456789101112131415161718192021class:&#123;&#125; //绑定class，和v-bind:class一样的APIstyle:&#123;&#125; //绑定样式，和v-bind:style一样的APIattrs:&#123;&#125; //添加自定义行间属性domProps:&#123;&#125; //DOM元素属性on:&#123;&#125; //绑定事件nativeOn:&#123;&#125; //监听原生事件directives:&#123;&#125; //自定义命令scopedSlots:&#123;&#125; //slot作用域slot:&#123;&#125; //定义slot名称key:&quot;key&quot; //给元素添加唯一标识ref:&quot;ref&quot; //引用信息 举个栗子：12345678910111213141516171819202122232425262728var vm = new Vue(&#123; el:&quot;#demo&quot;, data:obj, render(createElement)&#123; return createElement( &quot;ul&quot;, &#123; class:&#123; bg:true &#125;, style:&#123; fontSize : &apos;50px&apos; &#125;, attrs:&#123; abc:&quot;abc&quot; &#125;, domProps:&#123; innerHTML:&quot;&lt;li&gt;我是html&lt;/li&gt;&quot; &#125; &#125;, [ createElement(&quot;li&quot;,1), createElement(&quot;li&quot;,2), createElement(&quot;li&quot;,3) ] ); &#125;&#125;); 关于vue应该掌握的：基础：vue实例，模板语法，计算属性，class和style绑定，条件和列表渲染，事件处理器，表单控件绑定，组件。 进阶：vue插件编写，mixin混合，过渡效果，自定义指令，vue-router路由系统的使用，vueX状态管理器。 构建工具：javascript运行环境nodejs，模块管理和打包工具webpack，vue-cli脚手架配置。]]></content>
  </entry>
  <entry>
    <title><![CDATA[Vue基础]]></title>
    <url>%2F2018%2F08%2F15%2Fvue%E5%A4%A7%E7%89%9Bb%2F</url>
    <content type="text"><![CDATA[一、列表渲染v-for指令根据一组数组的选项列表进行渲染语法：value,key in items | value,key of items变异方法vue提供一组方法，对数组进行操作的时候，会触发视图更新。push() pop() shift() unshift() splice() sort() reverse() 二、事件处理器v-on指令用来监听DOM事件触发代码 语法：v-on:eventName=”eventHandle”指令简写：@事件处理函数：写在methods中统一管理事件对象：在事件处理函数中获取事件修饰符事件处理函数只有纯粹的逻辑判断，不处理DOM事件的细节。例如阻止冒泡，取消默认行为，判断按键。修饰符的位置：v-on:eventName.修饰符修饰符：.stop .prevent .capture .self .once按键修饰符：.enter .tab .delete .esc .space .up .down .left .right.ctrl .alt .shift .meta .键值 三、表单控件数据双向绑定v-model指令提供对表单元素进行双向数据绑定1&lt;input type=&quot;text&quot; v-model=&quot;todo&quot;/&gt; 上面代码将用户输入内容和vm.todo直接绑定，还可用于Radio,Checkbox,Select等。 四、动态绑定classv-bind指令用于动态绑定DOM元素属性，即元素属性实际值是由vm实例中的data属性提供的。class也为元素的属性，可以使用v-bind:class语法：v-bind:class=”{className:表达式}”（表达式值为true添加className）v-bind指令简写为： 五、条件渲染v-show指令根据表达式的值，用来显示或隐藏元素语法：v-show=”表达式”（表达式值为true显示）元素会被渲染在页面中，只根据表达式的值进行css切换 六、自定义指令除了vue内置的指令，可以自己设置指令选项对象的directives属性{ directives:{}}钩子函数update被绑定元素所在的模板更新时调用钩子函数中的参数： el:指令所绑定的元素，可以用来直接操作DOM binding:一个对象，包含很多属性 value:指令的绑定值 七、计算数据模板是为了描述视图的结构，模板中放入太多逻辑会导致模板过重难以维护。 例如下面在模板中筛选未完成任务个数，这样的写法是不够好的：1234567&lt;li&gt; &#123;&#123; list.filter(function(item)&#123; return !item.isChecked; &#125;).length &#125;&#125;&lt;/li&gt; 在计算一个属性时，vue.js更新它的依赖列表并缓存结果，只有当其中一个依赖发生了变化，缓存的结果才无效。语法：在选项对象中 { … computed:{} } 对上面的例子的改进：1234567computed:&#123; nocheckLength:function()&#123; return this.list.filter(function(item)&#123; return !item.isChecked; &#125;).length &#125;&#125;,]]></content>
  </entry>
</search>
